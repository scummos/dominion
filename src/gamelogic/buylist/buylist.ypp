%code requires {
  #include <vector>
  #include "buylist.h"
  #include "conditionfactory.h"
  #include "genericcardoption.h"
  #include "strategy.h"
}

%{
    #define YYERROR_VERBOSE
    #include <cstdio>
    #include <iostream>
    #include "buylist.h"
    #include "buylist.tab.hpp"
    using namespace std;

    extern int yylex(yy::parser::semantic_type*, yy::parser::location_type*);
    extern "C" {
        extern FILE *yyin;
    }

    extern int parse_buylist(char const* fn, BuylistCollection& ret, StrategyCollection& strats);
%}

%locations

%parse-param { BuylistCollection& ret }
%parse-param { StrategyCollection& strats }
%define parse.trace
%define parse.lac full
%define parse.error verbose

%language "c++"
%define api.value.type variant

// define the constant-string tokens:
%token BUYLISTS LIST END COMMENT LPAREN RPAREN NOT IF NEWLINE ARROW STRATEGIES STRATEGY PLAYORDER OPTIONS OPTION FOR CHOOSE IGNORE OPTIONAL

%token <int> INT
%token <std::string> STRING

%nterm <std::vector<Buylist>> lists
%nterm <Buylist> list
%nterm <std::vector<BuyAction>> list_entries
%nterm <BuyAction> list_entry

%nterm <std::vector<Strategy>> strats
%nterm <Strategy> strat
%nterm <Strategy> strat_body
%nterm <std::vector<Playorder>> playorders
%nterm <Playorder> playorder
%nterm <GenericCardOption> cardoption
%nterm <std::vector<GenericCardOption>> cardoptions
%nterm <std::any> cardoption_expr
%nterm <std::any> cardoption_expr_value
%nterm <std::vector<std::any>> cardoption_expr_list

%nterm <Condition::Ptr> condition
%nterm <std::vector<std::any>> func_arglist
%nterm <Condition::Ptr> condition_expr
%nterm <CardId> card_name
%nterm <std::any> expr
%nterm <std::any> constant

%%

buylist:
  buylist_section { }
  ;
buylist_section:
  BUYLISTS lists END STRATEGIES strats END {
      ret = BuylistCollection({$2});
      strats = StrategyCollection({$5});
    }
  ;
lists:
  lists list {
      $1.push_back($2);
      $$ = $1;
    }
  | list {
      $$ = std::vector<Buylist>{$1};
    }
  ;
list:
  LIST list_entries END {
      $$ = Buylist($2);
    }
  | LIST condition list_entries END {
      $$ = Buylist($2, $3);
    }
  ;
list_entries:
  list_entries list_separator list_entry {
      $1.push_back($3);
      $$ = $1;
    }
  | list_entry {
      $$ = {$1};
    }
  | %empty {
      $$ = {};
    }
  ;
list_separator:
  ',' | NEWLINE
  ;
list_entry:
  card_name {
      $$ = BuyAction($1);
    }
  | card_name condition {
      $$ = BuyAction($2, $1);
    }
  ;
condition:
  IF condition_expr {
      $$ = $2;
    }
  | IF NOT condition_expr {
      $$ = createCondition("Not", {$3});
    }
  ;
condition_expr:
  STRING '(' func_arglist ')' {
      try {
        $$ = createCondition($1, $3);
      }
      catch (InvalidConditionError e) {
        throw parser::syntax_error(yylhs.location, e.error);
      }
    }
  ;
func_arglist:
  expr {
      $$ = std::vector<std::any>{$1};
    }
  | func_arglist ',' expr {
      $1.push_back($3);
      $$ = $1;
    }
  ;
expr:
  constant {
      $$ = std::any($1);
    }
  | condition_expr {
      $$ = std::any($1);
    }
  ;
constant:
  INT {
      $$ = std::any($1);
    }
  | card_name {
      $$ = std::any($1);
    }
  ;
card_name:
  STRING {
      $$ = cardId($1);
      if ($$ == CardId::Invalid) {
        throw parser::syntax_error(yylhs.location, "Invalid card name");
      }
    }
  ;
strats:
  strats strat {
      $1.push_back($2);
      $$ = $1;
    }
  | strat {
      $$ = std::vector<Strategy>{$1};
    }
  ;
strat:
  STRATEGY strat_body END {
      $$ = $2;
    }
  | STRATEGY condition strat_body END {
      $3.setCondition($2);
      $$ = $3;
    }
  ;
strat_body:
  PLAYORDER playorders END cardoptions {
      $$ = Strategy($2, $4);
    }
  | PLAYORDER playorders END {
      $$ = Strategy($2, {});
    }
  | cardoptions {
      $$ = Strategy({}, $1);
    }
  | %empty {
      $$ = Strategy();
    }
  ;
playorders:
  playorders ',' playorder {
      $1.push_back($3);
      $$ = $1;
    }
  | playorder {
      $$ = std::vector<Playorder>({$1});
    }
  ;
playorder:
    card_name {
        $$ = Playorder($1);
      }
    | ':' STRING {
        $$ = Playorder($2);
      }
  ;
cardoptions:
  cardoptions cardoption {
      $1.push_back($2);
      $$ = $1;
    }
  | cardoption {
      $$ = std::vector<GenericCardOption>{$1};
    }
  ;
cardoption:
  OPTIONS FOR card_name cardoption_expr END {
      $$ = GenericCardOption{$3, {}, $4};
    }
  | OPTIONS FOR card_name condition cardoption_expr END {
      $$ = GenericCardOption{$3, $4, $5};
    }
  ;
cardoption_expr:
  cardoption_expr_value {
      $$ = $1;
    }
  | cardoption_expr_list ',' cardoption_expr_value {
      // only parse as list if it has at least 1 comma
      $1.push_back($3);
      $$ = $1;
    }
  ;
cardoption_expr_value:
  CHOOSE OPTION INT {
      $$ = std::any($3);
    }
  | CHOOSE OPTIONAL {
      $$ = std::any(true);
    }
  | IGNORE OPTIONAL {
      $$ = std::any(false);
    }
  | card_name ARROW card_name {
      $$ = std::make_pair($1, $3);
    }
  | card_name {
      $$ = std::any($1);
    }
  ;
cardoption_expr_list:
  cardoption_expr_list ',' cardoption_expr_value {
      $1.push_back($3);
      $$ = $1;
    }
  | cardoption_expr_value {
      $$ = std::vector<std::any>{$1};
    }
%%

int parse_buylist(char const* fn, BuylistCollection& ret, StrategyCollection& strats) {
  FILE *myfile = fopen(fn, "r");
  if (!myfile) {
    cout << "error opening file" << endl;
    return -1;
  }
  yyin = myfile;

  yy::parser p(ret, strats);
//   p.set_debug_level(1);
  int ok = p.parse();
  fclose(myfile);
  return ok;
}

void yy::parser::error (const location_type& l, const std::string& m) {
  cout << "Parse error in line " << l << ": " << m << endl;
  exit(-1);
}

